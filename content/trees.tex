\section{Trees}

\subsection{Binary Lifting / LCA}
\bigo{NlogN} time and space per construction, \bigo{logN} per query

\verb|Tree tree{adjacency_list};| // Creates a Tree rooted at 0 \\
\verb|Tree tree{adjacency_list, root};| // Creates a Tree rooted at root
\snippet{source/Tree.cpp}

\subsection{Heavy Light Decomposition}
\bigo{N} construction and memory usage, \bigo{log^2N} queries and updates on tree paths.
Builds a segment tree on the tree, and can do all things a lazy segment tree can do but on paths
\snippet{source/HLD.cpp}

\subsection{Subtree queries}
\bigo{N} construction and memory, \bigo{logN} time for query and update \\
Maps each subtree to a range of a SegmentTree.\\
Works both on lazy and normal segments. Lazy is required for subtree update

\snippet{source/subtree-query.cpp}

\subsection{Centroid Decomposition}
\bigo{NlogN} complexity, \bigo{N} memory usage.
A centroid is a vertex that if removed splits the tree in components of size <= n/2.
Centroid Decomposition works by recursively splitting the tree and its subtrees
at the centroid, producing \bigo{log N} layers of subtrees.
You can add a visit after finding the centroid to calculate what you need for each subtree

\snippet{source/centroid.cpp}

