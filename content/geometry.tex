\section{Geometry}
\todo{Circles, intersections, convex layers, triangulation}

\subsection{Constants}
\verb|EPS = 1e-9| default, check precision required by the problem and
change it accordingly.
\snippet{source/constants_geom.h}


\subsection{Point}
Use \verb|ll| as type - avoid \verb|ld| if possible.
\snippet{source/point.h}

\subsection{Line}
\snippet{source/line.h}

\subsection{Polygon}
Store vertices in counterclockwise (ccw) order.
Change \verb|vector<Point<ll>>| to another type if needed - strongly discouraged.
\snippet{source/polygon.h}

\subsection{Closest pair of points}

\bigo{N \log N}
Returns the pair of points with the smallest Euclidean distance

\verb|auto cp = closest_pair(points);|
\snippet{source/closest_pair_of_points.h}


\subsection{Convex Hull}
\bigo{N \log N} Time
Returns the convex hull of the points in counterclockwise order: \\
\verb|hull = convex_hull(points);|

If you want to include collinear edges: \\
\verb|hull = convex_hull(points, true);|

Change \verb|P| to \verb|Point<ld>| if you are dealing with floating point numbers
\snippet{source/convex_hull.h}


\subsection{Kd-Tree}
\bigo{\log N} per search

Data structure for keeping Kd (2d actually) points in order \\
\verb|KdTree tree{points};|

Find the point with the smallest Euclidean distance to the given point \\
\verb|P p = tree.nearest(from);|

Uncomment the commented code to not include the point itself in the search
\snippet{source/kd_tree.h}
